C51 COMPILER V9.60.7.0   DS1302                                                            10/24/2023 16:02:05 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DS1302
OBJECT MODULE PLACED IN .\Objects\DS1302.obj
COMPILER INVOKED BY: E:\keil1\C51\BIN\C51.EXE APP\DS1302.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\APP;.\USER) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\DS1302.lst) TABS(2) OBJECT(.\Objects\DS1302.obj)

line level    source

   1          //#include "AllHead.h"
   2          
   3          ////---DS1302写入和读取时分秒的地址命令---//
   4          ////---秒分时日月周年 最低位读写位;-------//
   5          //u8 Write_addr[7] = {0x80,0x82,0x84,0x86,0x88,0x8a,0x8c};//数据可查看各类寄存器
   6          //u8 Read_addr[7] = {0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};
   7          
   8          ////---DS1302时钟初始化2023年10月14日星期六16点36分30秒。---//
   9          ////---存储顺序是秒分时日月周年,存储格式是用BCD码---//
  10          //u8 DS1302_Time[7] = {0x30,0x36,0x16,0x14,0x10,0x06,0x23};
  11          
  12          ///*******************************************************************************
  13          //* 函 数 名   : DS1302_Write_Byte
  14          //* 函数功能     : DS1302写单字节
  15          //* 输    入   : addr：地址/命令
  16          //                dat：数据
  17          //* 输    出   : 无
  18          //*******************************************************************************/
  19          //void DS1302_Write_Byte(u8 addr,u8 dat)
  20          //{
  21          //  u8 i;
  22          //  
  23          //  DS1302_CE = 0;    //首先CE输出低电平
  24          //  _nop_();          //延时1us
  25          //  DS1302_SCK = 0;   //SCLK也输出低电平
  26          //  _nop_();
  27          //  DS1302_CE = 1;    //在读写过程，CE要保持高电平
  28          //  _nop_(); 
  29          //  
  30          //  for(i = 0; i < 8; i++)         //循环8次，每次写1位，先写低位再写高位
  31          //  {
  32          //    DS1302_IO = addr & 0x01;     //取出控制寄存器地址的最低位赋给DS1302的IO口
  33          //    addr >>= 1;                  //将控制寄存器地址的次低位移到最低位
  34          //    DS1302_SCK = 1;              //SCLK由低到高产生一个上升沿，从而写入数据
  35          //    _nop_();                     //延时1us
  36          //    DS1302_SCK = 0;              //SCLK先拉低，以便下一次上升沿
  37          //    _nop_();
  38          //  }
  39          //  
  40          //  for(i = 0; i < 8; i++)
  41          //  {
  42          //    DS1302_IO = dat & 0x01;      //取出写入数据的最低位赋给DS1302的IO口
  43          //    dat >>= 1;                   //将数据的次低位移到最低位
  44          //    DS1302_SCK = 1;      
  45          //    _nop_();          
  46          //    DS1302_SCK = 0;
  47          //    _nop_();
  48          //  }
  49          //  DS1302_CE = 0;  //CE拉低
  50          //  _nop_();
  51          //}
  52          
  53          ///*******************************************************************************
  54          //* 函 数 名   : DS1302_Read_Byte
C51 COMPILER V9.60.7.0   DS1302                                                            10/24/2023 16:02:05 PAGE 2   

  55          //* 函数功能     : DS1302读单字节
  56          //* 输    入   : addr：地址/命令
  57          //* 输    出   : 读取的数据
  58          //*******************************************************************************/
  59          //u8 DS1302_Read_Byte(u8 addr)
  60          //{
  61          //  u8 i;
  62          //  u8 dat;          //将接收到的数据存放到这个变量
  63          //  
  64          //  DS1302_CE = 0;   //首先CE输出低电平
  65          //  _nop_();         //延时1us
  66          //  DS1302_SCK = 0;  //SCLK也输出低电平
  67          //  _nop_();
  68          //  DS1302_CE = 1;   //在读写过程，CE要保持高电平
  69          //  _nop_(); 
  70          //  
  71          //  for(i = 0; i < 8; i++)         //循环8次，每次写1位，先写低位再写高位
  72          //  {
  73          //    DS1302_IO = addr & 0x01;     //取出控制寄存器地址的最低位赋给DS1302的IO口
  74          //    addr >>= 1;                  //将控制寄存器地址的次低位移到最低位
  75          //    DS1302_SCK = 1;              //SCLK由低到高产生一个上升沿，从而写入数据
  76          //    _nop_();                     //延时1us
  77          //    DS1302_SCK = 0;              //SCLK先拉低，以便下一次上升沿
  78          //    _nop_();
  79          //  }
  80          //  
  81          //  for(i = 0; i < 8; i++)        //循环8次，每次写1位，先写低位再写高位
  82          //  {
  83          //    dat >>= 1;                  //将数据的次低位移到最低位
  84          //    if(DS1302_IO)               //如果读取到的数据为1
  85          //      dat |= 0x80;              //dat相对应的值为1，否则不进入if语句，dat默认为0
  86          //    DS1302_SCK = 1;
  87          //    _nop_();                    //延时1us
  88          //    DS1302_SCK = 0;             //SCLK由高到低产生一个下降沿，从而读入数据
  89          //    _nop_();
  90          //  }
  91          //  DS1302_CE = 0; //CE拉低
  92          //  _nop_();
  93          //  
  94          //  return dat;    //将读取到的数据返回出去
  95          //}
  96          
  97          ///*******************************************************************************
  98          //* 函 数 名       : DS1302_Init
  99          //* 函数功能         : DS1302初始化时间
 100          //* 输    入       : 无
 101          //* 输    出       : 无
 102          //*******************************************************************************/
 103          //void DS1302_Init(void)
 104          //{
 105          //  u8 i;
 106          //  DS1302_Write_Byte(0x8E,0x00); //关闭写保护(写保护寄存器的地址为0x8E,WP为其中的最高位，WP为0即为关闭写保
             -护)
 107          //  for(i = 0; i < 7; i++)
 108          //  {
 109          //    DS1302_Write_Byte(Write_addr[i],DS1302_Time[i]);
 110          //  }
 111          //  DS1302_Write_Byte(0x8E,0x80); //打开写保护，以防止意外修改DS1302内部寄存器(WP为1即为打开写保护)
 112          //}
 113          
 114          ///*******************************************************************************
 115          //* 函 数 名       : DS1302_Read_Time
C51 COMPILER V9.60.7.0   DS1302                                                            10/24/2023 16:02:05 PAGE 3   

 116          //* 函数功能         : DS1302读取时间
 117          //* 输    入       : 无
 118          //* 输    出       : 无
 119          //*******************************************************************************/
 120          //void DS1302_Read_Time(void)
 121          //{
 122          //  u8 i;
 123          //  for(i = 0; i < 7; i++)
 124          //  {
 125          //    DS1302_Time[i] = DS1302_Read_Byte(Read_addr[i]);
 126          //  }
 127          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
