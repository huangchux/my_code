C51 COMPILER V9.60.7.0   UART                                                              10/24/2023 19:07:34 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\UART.obj
COMPILER INVOKED BY: E:\keil1\C51\BIN\C51.EXE APP\UART.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\APP;.\USER) DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\UART.lst) TABS(2) OBJECT(.\Objects\UART.obj)

line level    source

   1          #include "AllHead.h"
   2          
   3          bit flag = 0;
   4          u8 rec_buf[10];
   5          
   6          /* úbaud-ͨŲ */
   7          void UAER_Init(u16 baud)
   8          {
   9   1          SCON = 0x50;  //ôΪģʽ 1  0101 0000 --> 0x50
  10   1          TMOD &= 0x0F; // T1 Ŀλ
  11   1          TMOD |= 0x20; // T1 Ϊģʽ 2  0010 0000 --> 0x20
  12   1          TH1 = 256 - (11059200 / 12 / 32) / baud; // T1 ֵ
  13   1          TL1 = TH1;  //ֵֵ
  14   1          
  15   1          ET1 = 0;    //ֹ T1 ж
  16   1          TR1 = 1;    // T1
  17   1      }
  18          
  19          
  20          /* жϷ */
  21          void UART() interrupt 4
  22          {
  23   1        u8 rec_dat = 0;
  24   1        static u8 i = 0;
  25   1        if((1 == RI) && (0 == flag))  //յֽ
  26   1        {
  27   2          rec_dat = SBUF;
  28   2          if((rec_dat == '\n') && (rec_buf[i - 1] == '\r'))
  29   2          {
  30   3            rec_buf[i - 1] = '\0'; // \r λõڽ
  31   3            i = 0;
  32   3            flag = 1;
  33   3          }
  34   2          else
  35   2          {
  36   3            rec_buf[i] = rec_dat;
  37   3            i++;
  38   3          }
  39   2        }
  40   1        RI = 0;
  41   1      }
  42          
  43          
  44          ///* д룬ڷͺbuf-ݵָ룬len-ָķͳ */
  45          //void Uart_Write(u8 *buf, u8 len)
  46          //{
  47          //  while(len--)  //ѭֽ
  48          //  {
  49          //    flagTxd = 0;      //㷢ͱ־
  50          //    SBUF = *buf++;    //һֽ
  51          //    while(!flagTxd);  //ȴֽڷ
  52          //  } 
  53          //}
  54          
C51 COMPILER V9.60.7.0   UART                                                              10/24/2023 19:07:34 PAGE 2   

  55          ///* ݶȡbuf-ָ룬len-ָĶȡȣֵ-ʵʶĳ */
  56          //u8 UartRead(u8 *buf, u8 len)
  57          //{
  58          //  u8 i = 0;
  59          //  if(len > cntRxd) //ָȡȴʵʽյݳʱ
  60          //  {
  61          //    len = cntRxd;  //ȡΪʵʽյݳ
  62          //  }
  63          //  for(i = 0; i < len; i++) //յݵָ
  64          //  {
  65          //    *buf++ = bufRxd[i];
  66          //  }
  67          //  cntRxd = 0; //ռ
  68          //  return len; //ʵʶȡ
  69          //}
  70          
  71          ///* ڽռأɿʱж֡ڶʱжеãms-ʱ */
  72          //void Uart_RxMonitor(u8 ms)
  73          //{
  74          //  static u8 cntbkp = 0;   //ǰһνյݵĳ
  75          //  static u8 idletmr = 0;  //мʱ
  76          
  77          //  if(cntRxd > 0)          //ռʱ߿ʱ
  78          //  {
  79          //    if(cntbkp != cntRxd)  //ռı䣬սյʱмʱ(ǰһνյݳȲһ
             -յ)
  80          //    {
  81          //      cntbkp = cntRxd;    //ѱνյݸǰһνյ
  82          //      idletmr = 0;
  83          //    }
  84          //    else                  //ռδı䣬߿ʱۻʱ
  85          //    {
  86          //      if(idletmr < 30)    //мʱС 30ms ʱۼ
  87          //      {
  88          //        idletmr += ms;
  89          //        if(idletmr >= 30) //ʱﵽ 30ms ʱжΪһ֡
  90          //        {
  91          //          flagFrame = 1;  //֡ɱ־
  92          //        }
  93          //      }
  94          //    }
  95          //  }
  96          //  else
  97          //    cntbkp = 0;
  98          //}
  99          
 100          ///* ֡Ľգȹܺѭе */
 101          //void Uart_Driver()
 102          //{
 103          //  u8 len;
 104          //  u8 pdata buf[40]; //ݻ
 105          //  if(flagFrame)     //ʱȡ
 106          //  {
 107          //    flagFrame = 0;
 108          //    len = UartRead(buf,sizeof(buf)); //յȡ
 109          //    Uart_Action(buf, len);           //֡öִк
 110          //  }
 111          //}


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     98    ----
C51 COMPILER V9.60.7.0   UART                                                              10/24/2023 19:07:34 PAGE 3   

   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
