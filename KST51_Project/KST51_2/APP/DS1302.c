//#include "AllHead.h"

////---DS1302写入和读取时分秒的地址命令---//
////---秒分时日月周年 最低位读写位;-------//
//u8 Write_addr[7] = {0x80,0x82,0x84,0x86,0x88,0x8a,0x8c};//数据可查看各类寄存器
//u8 Read_addr[7] = {0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};

////---DS1302时钟初始化2023年10月14日星期六16点36分30秒。---//
////---存储顺序是秒分时日月周年,存储格式是用BCD码---//
//u8 DS1302_Time[7] = {0x30,0x36,0x16,0x14,0x10,0x06,0x23};

///*******************************************************************************
//* 函 数 名   : DS1302_Write_Byte
//* 函数功能		 : DS1302写单字节
//* 输    入   : addr：地址/命令
//				        dat：数据
//* 输    出   : 无
//*******************************************************************************/
//void DS1302_Write_Byte(u8 addr,u8 dat)
//{
//	u8 i;
//	
//	DS1302_CE = 0;    //首先CE输出低电平
//	_nop_();          //延时1us
//	DS1302_SCK = 0;   //SCLK也输出低电平
//	_nop_();
//	DS1302_CE = 1;    //在读写过程，CE要保持高电平
//	_nop_(); 
//	
//	for(i = 0; i < 8; i++)         //循环8次，每次写1位，先写低位再写高位
//	{
//		DS1302_IO = addr & 0x01;     //取出控制寄存器地址的最低位赋给DS1302的IO口
//		addr >>= 1;                  //将控制寄存器地址的次低位移到最低位
//		DS1302_SCK = 1;              //SCLK由低到高产生一个上升沿，从而写入数据
//		_nop_();                     //延时1us
//	  DS1302_SCK = 0;              //SCLK先拉低，以便下一次上升沿
//	  _nop_();
//	}
//	
//	for(i = 0; i < 8; i++)
//	{
//		DS1302_IO = dat & 0x01;      //取出写入数据的最低位赋给DS1302的IO口
//		dat >>= 1;                   //将数据的次低位移到最低位
//		DS1302_SCK = 1;      
//		_nop_();          
//	  DS1302_SCK = 0;
//	  _nop_();
//	}
//	DS1302_CE = 0;  //CE拉低
//	_nop_();
//}

///*******************************************************************************
//* 函 数 名   : DS1302_Read_Byte
//* 函数功能		 : DS1302读单字节
//* 输    入   : addr：地址/命令
//* 输    出   : 读取的数据
//*******************************************************************************/
//u8 DS1302_Read_Byte(u8 addr)
//{
//	u8 i;
//	u8 dat;          //将接收到的数据存放到这个变量
//	
//	DS1302_CE = 0;   //首先CE输出低电平
//	_nop_();         //延时1us
//	DS1302_SCK = 0;  //SCLK也输出低电平
//	_nop_();
//	DS1302_CE = 1;   //在读写过程，CE要保持高电平
//	_nop_(); 
//	
//	for(i = 0; i < 8; i++)         //循环8次，每次写1位，先写低位再写高位
//	{
//		DS1302_IO = addr & 0x01;     //取出控制寄存器地址的最低位赋给DS1302的IO口
//		addr >>= 1;                  //将控制寄存器地址的次低位移到最低位
//		DS1302_SCK = 1;              //SCLK由低到高产生一个上升沿，从而写入数据
//		_nop_();                     //延时1us
//	  DS1302_SCK = 0;              //SCLK先拉低，以便下一次上升沿
//	  _nop_();
//	}
//	
//	for(i = 0; i < 8; i++)        //循环8次，每次写1位，先写低位再写高位
//	{
//		dat >>= 1;                  //将数据的次低位移到最低位
//		if(DS1302_IO)               //如果读取到的数据为1
//			dat |= 0x80;              //dat相对应的值为1，否则不进入if语句，dat默认为0
//		DS1302_SCK = 1;
//		_nop_();                    //延时1us
//	  DS1302_SCK = 0;             //SCLK由高到低产生一个下降沿，从而读入数据
//	  _nop_();
//	}
//	DS1302_CE = 0; //CE拉低
//	_nop_();
//	
//	return dat;    //将读取到的数据返回出去
//}

///*******************************************************************************
//* 函 数 名       : DS1302_Init
//* 函数功能		     : DS1302初始化时间
//* 输    入       : 无
//* 输    出    	 : 无
//*******************************************************************************/
//void DS1302_Init(void)
//{
//	u8 i;
//	DS1302_Write_Byte(0x8E,0x00); //关闭写保护(写保护寄存器的地址为0x8E,WP为其中的最高位，WP为0即为关闭写保护)
//	for(i = 0; i < 7; i++)
//	{
//		DS1302_Write_Byte(Write_addr[i],DS1302_Time[i]);
//	}
//	DS1302_Write_Byte(0x8E,0x80); //打开写保护，以防止意外修改DS1302内部寄存器(WP为1即为打开写保护)
//}

///*******************************************************************************
//* 函 数 名       : DS1302_Read_Time
//* 函数功能		     : DS1302读取时间
//* 输    入       : 无
//* 输    出    	 : 无
//*******************************************************************************/
//void DS1302_Read_Time(void)
//{
//	u8 i;
//	for(i = 0; i < 7; i++)
//	{
//		DS1302_Time[i] = DS1302_Read_Byte(Read_addr[i]);
//	}
//}