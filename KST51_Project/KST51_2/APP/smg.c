//#include "AllHead.h"

//u8 gsmg[16] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
//               0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E}; //数码管0-F
//u8 SMG_BUFF[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; //数码管显示缓冲区，初值0xFF

///* 将一个无符号长整型的数字显示到数码管上，num-待显示数字 */
//void SMG_Show(u32 num)
//{
//	signed char i; //由于i是--，最后会减为0，如果换成无符号的话再减就变成256了，所以这里要写出有符号的变量
//	u8 buf[6];             //数据转换的缓冲区
//	for(i = 0; i < 6; i++) //把长整型数转换为 6 位十进制的数组
//	{
//		buf[i] = num % 10;   //取出最低位到数码管上
//		num /= 10;           //去掉最低位
//	}
//	for(i = 5; i > 0; i--) //从最高位起，遇到 0 转换为空格，遇到非 0 则退出循环
//	{
//		if(0 == buf[i])      //如果该数码管显示的数为0则关闭该数码管
//		{
//			SMG_BUFF[i] = 0xFF;
//		}
//		else
//			break;
//	}
//	for(; i >= 0; i--)     //剩余低位都如实转换为数码管显示字符

//	{
//		SMG_BUFF[i] = gsmg[buf[i]];
//	}
//}	

///* 数码管动态扫描刷新函数，需在定时中断中调用 */
//void Smg_Scan()
//{
//	static u8 i;                //动态扫描索引
//	LED_SMG_PORT = 0xFF;        //关闭所有段选位，显示消隐
//	//先将P1的第三位取0(低三位与0进行与运算)，然后再与i进行或运算，如果i为1，P1第三位(也就是ADDR2-ADDR0)为001，以此类推
//	P1 = (P1 & 0xF8) | i;       //位选索引值赋值到P1口低3位
//	LED_SMG_PORT = SMG_BUFF[i]; //索引递增循环，遍历整个缓冲区，由于加了LED显示，点亮LED需要使能LEDS6,所以i小于6不是小于5
//	if(i < sizeof(SMG_BUFF)-1)
//		i++;
//	else
//		i = 0;
//}
