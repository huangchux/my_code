#include "AllHead.h"

/*******************************************************************************
* 函 数 名 : ds18b20_reset
* 函数功能 : 复位 DS18B20
* 输 入 : 无
* 输 出 : 无
*******************************************************************************/
//void ds18b20_reset(void)
//{
//	DS18B20_PORT = 0; //拉低 DQ
//	delay_10us(75);   //延时750微秒
//	DS18B20_PORT = 1; //拉高DQ DQ = 1
//	delay_10us(2);    //延时20微秒
//}	

///*******************************************************************************
//* 函 数 名 : ds18b20_check
//* 函数功能 : 检测 DS18B20 是否存在
//* 输 入 : 无
//* 输 出 : 1:未检测到 DS18B20 的存在，0:存在
//*******************************************************************************/
//u8 ds18b20_check(void)
//{
//	u8 time_temp = 0;  //设置时间变量原因是如果DQ一直为高电平的话不能一直在这里死循环，如果等待一会DQ还是高电平的话则强制退出
//	while(DS18B20_PORT && time_temp < 20) //等待DQ为低电平(如果DQ为1且时间变量小于20则进入循环，如果为低电平0则跳出循环) 
//	{
//		time_temp++;  
//		delay_10us(1);
//	}
//	if(time_temp >= 20) return 1; //如果超时则强制返回 1，证明DS18B20不存在
//	else  time_temp = 0;
//	
//	while((!DS18B20_PORT) && time_temp < 20) //等待DQ为高电平(如果DQ为0且时间变量小于20则进入循环，如果为高电平1则跳出循环) 
//	{
//		time_temp++;
//		delay_10us(1);
//	}
//	if(time_temp >= 20) return 1; //如果超时则强制返回 1，证明DS18B20不存在
//	else
//		return 0; //证明DS18B20存在
//}

///*******************************************************************************
//* 函 数 名 : ds18b20_init
//* 函数功能 : 初始化 DS18B20 的 IO 口 DQ, 同时检测 DS 的存在
//* 输 入 : 无
//* 输 出 : 1:不存在，0:存在
//*******************************************************************************/
//u8 ds18b20_init(void)
//{
//	ds18b20_reset();
//	return ds18b20_check();
//}

///*******************************************************************************
//* 函 数 名         : ds18b20_write_byte
//* 函数功能		   : 写一个字节到DS18B20
//* 输    入         : dat：要写入的字节
//* 输    出         : 无
//*******************************************************************************/
//void ds18b20_write_byte(u8 dat)
//{
//	u8 i = 0;
//	u8 temp = 0;
//	for(i = 0;i < 8;i++) //循环8次，每次写一位，且先写低位再写高位
//	{                    //例如data为 0101 1011
//		temp = dat & 0x01; //选择低位准备写入(则temp为0000 0001 )
//		dat >>= 1;         //将次低位移到最低位，例如一开始dat为0101 1011 向右移动一位则变成 0010 1101
//		if(temp)           //如果写 1 时序
//		{
//			DS18B20_PORT = 0;//主机拉低总线
//			_nop_();_nop_(); //延时两毫秒(该函数为头文件intrins.h里的函数，一个_nop_()表示延时 1 毫秒)
//			DS18B20_PORT = 1;//释放总线
//			delay_10us(6);   //延时 60 us
//		}
//		else               //写入 0 时序
//		{
//			DS18B20_PORT = 0;//主机拉低总线
//			delay_10us(6);   //延时 60 us
//			DS18B20_PORT = 1;//释放总线
//			_nop_();_nop_(); //延时两毫秒(该函数为头文件intrins.h里的函数，一个_nop_()表示延时 1 毫秒)
//		}
//	}
//}

///*******************************************************************************
//* 函 数 名         : ds18b20_read_bit
//* 函数功能		       : 从DS18B20读取一个位
//* 输    入         : 无
//* 输    出         : 1/0
//*******************************************************************************/
//u8 ds18b20_read_bit(void)
//{
//	u8 dat = 0;
//	DS18B20_PORT = 0;
//	_nop_();_nop_();
//	DS18B20_PORT = 1;
//	_nop_();_nop_();  //该段时间不能过长，必须在15us内读取数据
//	if(DS18B20_PORT) 
//		dat = 1;        //如果总线上为1则数据dat为1，否则为0
//	else
//		dat = 0;
//	delay_10us(5);
//	return dat;
//}

///*******************************************************************************
//* 函 数 名         : ds18b20_read_byte
//* 函数功能		       : 从DS18B20读取一个字节
//* 输    入         : 无
//* 输    出         : 一个字节数据
//*******************************************************************************/
//u8 ds18b20_read_byte(void)
//{
//	u8 i = 0;
//	u8 dat = 0;
//	u8 temp = 0;
//	for(i = 0;i < 8;i++)  //循环8次，每次读取一位，且先读低位再读高位
//	{
//		temp = ds18b20_read_bit(); //将接收到的位赋给temp 例如temp接收到1
//		dat = (temp << 7) | (dat >> 1); //dat向右移动一位，将最高位移到次高位,temp向左移动7位将最低位移到最高位
//		                     // 0000 0001 << 7 --> 1000 0000 ,接着两个进行或运算的结果赋给dat，此目的是为了保留dat的值 
//		                     //接着将dat向右移动1位到次高位与重新接收到的temp向左移动7位来进行或运算，以此类推进行八次循环
//	}
//	return dat;
//}

///*******************************************************************************
//* 函 数 名         : ds18b20_start
//* 函数功能		       : 开始温度转换
//* 输    入         : 无
//* 输    出         : 无
//*******************************************************************************/
//void ds18b20_start(void)
//{
//	ds18b20_reset();          //复位
//	ds18b20_check();          //检查DS18B20是否存在
//	ds18b20_write_byte(0xCC); //发SKIP ROM 命令
//	ds18b20_write_byte(0x44); //发开始转换命令
//}

///*******************************************************************************
//* 函 数 名         : ds18b20_read_temperture(温度读取函数)
//* 函数功能		       : 从ds18b20得到温度值
//* 输    入         : 无
//* 输    出         : 温度数据
//*******************************************************************************/
//u8 ds18b20_read_temperture(void)
//{
//	u8 dath = 0; 
//	u8 datl = 0; 
//	u16 value = 0; 
//	float temp;
//	
//	ds18b20_start();
//	ds18b20_reset();          //复位
//	ds18b20_check();          //检查DS18B20是否存在
//	ds18b20_write_byte(0xCC); //发SKIP ROM 命令
//	ds18b20_write_byte(0xBE); //读存储器
//	
//	datl = ds18b20_read_byte(); //低八位字节数据
//	dath = ds18b20_read_byte(); //高八位字节数据
//	value = (dath << 8) + datl;//合并为16位的数据
//	
//	if(value && 0xF800 == 0xf800) //判断符号位，负温度(如果该16位数据中前五位为 1 则表示温度小于0 )
//	{
//		value = (~value) + 1;     //读取到的数据取反再加1
//		temp = value * (-0.0625);	//乘以精度
//	}
//	else   //如果该16位数据中前五位为 0 则表示温度大于0
//		temp = value * 0.0625; //读取到的数据直接乘以精度得出温度
//	return temp;
//}

