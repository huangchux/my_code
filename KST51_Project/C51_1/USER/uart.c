#include "AllHead.h"
/*******************************************************************************
* 函 数 名 : uart_init
* 函数功能 : 串口通信中断配置函数，通过设置 TH 和 TL 即可确定定时时间
* 输 入 : baud：波特率对应的 TH、TL 装载值
* 输 出 : 无
*******************************************************************************/
/*void UART_Init(u8 baud)
{
	TMOD |= 0X20;  //设置计数器工作方式2  0010 0000 --> 0x20
	SCON = 0X50;   //设置为工作方式1      0101 0000 --> 0x50
	PCON = 0X80;   //波特率加倍           1000 0000 --> 0x80
	TH1 = baud;    //计数器初始值设置(使用小工具)
	TH1 = baud;
	ES = 1;        //打开接收中断
	EA = 1;        //打开总中断
	TR1 = 1;       //打开计数器
}*/
/*void UART_SendByte(u8 Byte)  //写数据到SBUF 
{
	SBUF = Byte;  //将数据写入串口数据缓存寄存器
	while(!TI);   //等待发送数据完成 TI=1即为发送完成 (发送完成 TI 会自动置1，!1为 0 则跳出循环)
	TI = 0;    //串行发送停止位的开始时，内部硬件会将TI置1，要清除发送完成标志位，需要清0，取消此中断申请
}*/
/*void uart() interrupt 4  //串口通信中断服务函数 (接收数据需要使用中断)
{
	if(RI == 1)      //如果接收标志位为1，接收到了数据
	{ 
		//当接收到数据的时候，让控制led的P2端口等于串口数据缓冲寄存器中的值，从而实现串口控制led灯
		LED_PORT = ~SBUF;    //因为0为灯亮，所以要取反
		UART_SendByte(SBUF); //将收到的数据发回串口
		RI = 0;   //串行接收停止位的中间时，内部硬件会将RI置1，要清除接收中断标志位，需要清0，取消此中断申请
	}
}*/

//void uart() interrupt 4  //串口通信中断服务函数
//{
//	u8 rec_data; 
//	RI = 0;     //串行接收停止位的中间时，内部硬件会将RI置1，要清除接收中断标志位，需要清0，取消此中断申请
//	rec_data = SBUF;    //存储接收到的数据
//	SBUF = rec_data;    //将接收到的数据放入到发送寄存器
//	while(!TI);         //等待发送数据完成(发送完成 TI 会自动置1，!1为 0 则跳出循环)
//	TI = 0;     //串行发送停止位的开始时，内部硬件会将TI置1，要清除发送完成标志位，需要清0，取消此中断申请
//}

