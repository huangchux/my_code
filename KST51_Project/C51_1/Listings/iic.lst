C51 COMPILER V9.60.7.0   IIC                                                               11/11/2023 13:00:54 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE IIC
OBJECT MODULE PLACED IN .\Objects\iic.obj
COMPILER INVOKED BY: E:\keil1\C51\BIN\C51.EXE USER\iic\iic.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER;.\USER;.\USER\iic;.\
                    -USER\EEPROM;.\USER\time;.\USER\DS18B20;.\USER\DS1302;.\USER\ired) DEBUG OBJECTEXTEND PRINT(.\Listings\iic.lst) TABS(2) O
                    -BJECT(.\Objects\iic.obj)

line level    source

   1          #include "AllHead.h"
   2          
   3          ///*******************************************************************************
   4          //* 函 数 名 : iic_start
   5          //* 函数功能 : 产生 IIC 起始信号
   6          //* 输 入 : 无
   7          //* 输 出 : 无
   8          //*******************************************************************************/
   9          //void iic_start(void)
  10          //{
  11          //  IIC_SCL = 1;
  12          //  IIC_SDA = 1;
  13          //  delay_10us(1);
  14          //  IIC_SDA = 0;   //当SCL为高电平时，SDA由高变为低
  15          //  delay_10us(1);
  16          //  IIC_SCL = 0;   //钳住I2C总线，准备发送或接收数据(SCL为低电平时数据可以改变)
  17          //}
  18          
  19          ///*******************************************************************************
  20          //* 函 数 名 : iic_stop
  21          //* 函数功能 : 产生 IIC 停止信号
  22          //* 输 入 : 无
  23          //* 输 出 : 无
  24          //*******************************************************************************/
  25          //void iic_stop(void)
  26          //{
  27          //  IIC_SCL = 1;
  28          //  IIC_SDA = 0;
  29          //  delay_10us(1);
  30          //  IIC_SDA = 1;    //当SCL为高电平时，SDA由低变为高
  31          //  delay_10us(1);
  32          //}
  33          
  34          ///*******************************************************************************
  35          //* 函 数 名 : iic_ack
  36          //* 函数功能 : 产生 ACK 应答
  37          //* 输 入 : 无
  38          //* 输 出 : 无
  39          //*******************************************************************************/
  40          //void iic_ack(void)
  41          //{
  42          //  IIC_SCL = 0;
  43          //  IIC_SDA = 0;   //SDA为低电平
  44          //  delay_10us(1);
  45          //  IIC_SCL = 1;
  46          //  delay_10us(1);
  47          //  IIC_SCL = 0;
  48          //}
  49          
  50          ///*******************************************************************************
  51          //* 函 数 名 : iic_nack
  52          //* 函数功能 : 产生 NACK 非应答
  53          //* 输 入 : 无
C51 COMPILER V9.60.7.0   IIC                                                               11/11/2023 13:00:54 PAGE 2   

  54          //* 输 出 : 无
  55          //*******************************************************************************/
  56          //void iic_nack(void)
  57          //{
  58          //  IIC_SCL = 0;
  59          //  IIC_SDA = 1;   //SDA为高电平
  60          //  delay_10us(1);
  61          //  IIC_SCL = 1;
  62          //  delay_10us(1);
  63          //  IIC_SCL = 0;
  64          //}
  65          
  66          ///*******************************************************************************
  67          //* 函 数 名 : iic_wait_ack
  68          //* 函数功能 : 等待应答信号到来
  69          //* 输 入 : 无
  70          //* 输 出 : 1，接收应答失败
  71          //          0，接收应答成功
  72          //*******************************************************************************/
  73          //u8 iic_wait_ack(void)
  74          //{
  75          //  u8 time_temp = 0; //计时变量
  76          //  IIC_SCL = 1;
  77          //  delay_10us(1);
  78          //  while(IIC_SDA)  //等待SDA为低电平(SDA为1进入循环，为0则跳出循环)
  79          //  {
  80          //    time_temp++;
  81          //    if(time_temp > 100)  //超时则强制结束IIC通信
  82          //    {
  83          //      iic_stop();        //强制结束IIC通信
  84          //      return 1;          //返回1(接收应答失败)
  85          //    } 
  86          //  }
  87          //  IIC_SCL = 0;
  88          //  return 0;              //返回0(接收应答成功)
  89          //}
  90          
  91          
  92          ///*******************************************************************************
  93          //* 函 数 名 : iic_write_byte
  94          //* 函数功能 : IIC 发送一个字节
  95          //* 输 入 : dat：发送一个字节
  96          //* 输 出 : 无
  97          //*******************************************************************************/
  98          //void iic_write_byte(u8 dat)
  99          //{
 100          //  u8 i = 0;
 101          //  IIC_SCL = 0;  //为0数据才可以改变
 102          //  for(i = 0;i < 8; i++)
 103          //  {
 104          //    if((dat & 0x80) > 0) //比较最高位 (如1011 0100 & 1000 0000 --> 1000 0000 最高位等于1 大于0)
 105          //      IIC_SDA = 1;
 106          //    else
 107          //      IIC_SDA = 0;
 108          //    dat <<= 1;     //左移一位(将次高位移到最高位)
 109          //    delay_10us(1);
 110          //    IIC_SCL = 1;  //为1数据稳定等待下一次传输
 111          //    delay_10us(1);
 112          //    IIC_SCL = 0;  //数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输
 113          //    delay_10us(1);
 114          //  }
 115          //}
C51 COMPILER V9.60.7.0   IIC                                                               11/11/2023 13:00:54 PAGE 3   

 116          
 117          
 118          ///*******************************************************************************
 119          //* 函 数 名 : iic_read_byte
 120          //* 函数功能 : IIC 读一个字节
 121          //* 输 入 : ack=1 时，发送 ACK，ack=0，发送 nACK
 122          //* 输 出 : 应答或非应答
 123          //*******************************************************************************/
 124          //u8 iic_read_byte(u8 ack)
 125          //{
 126          //  u8 i = 0;
 127          //  u8 receive = 0;  //保存读取的数据
 128          //  for(i = 0; i < 8; i++)  //循环8次将一个字节读出，先读高位再传低位
 129          //  {
 130          //    IIC_SCL = 0;
 131          //    delay_10us(1);
 132          //    IIC_SCL = 1;   //SCL为1时数据稳定，可以传输数据
 133          //    delay_10us(1);
 134          //    receive <<= 1; //将接收到的数据向左移动一位 (假设要传输 1001 1000，则先接收到高位1，则SDA为1，
 135          //    if(IIC_SDA)    //如果SDA为1                 receive加1，则receive为 0000 0001，之后将receive
 136          //      receive++;   //则接收到的数据加1          向左移动一位，则receive为 0000 0010,接着传输第二位0，
 137          //    delay_10us(1);                      //     则SDA为0，不进入if语句，receive接收到0，则receive   
 138          //                                        //     为 0000 0010，之后将receive向左移动一位，则receive为 
 139          //  }                                     //     0000 0100 以此类推接收数据，直到数据传输完成则跳出循环)
 140          //  if(!ack)
 141          //    iic_nack();     //非应答
 142          //  else
 143          //    iic_ack();      //应答
 144          //  return receive;   //返回出去
 145          //}
 146          
 147          
 148          
 149          
 150          ///**
 151          //  * @brief    I2C开始 产生 IIC 起始信号
 152          //  * @param    无
 153          //  * @retval   无
 154          //  */
 155          //void I2C_Start(void)
 156          //{
 157          //  I2C_SDA=1;  //先确保SDA为1
 158          //  I2C_SCL=1;  //再把SCL拉高
 159          //  I2C_SDA=0;  //当SCL为高电平时，SDA由高变为低
 160          //  I2C_SCL=0;  //钳住I2C总线，准备发送或接收数据(SCL为低电平时数据可以改变)
 161          //}
 162          
 163          ///**
 164          //  * @brief  I2C停止 产生IIC停止信号
 165          //  * @param  无
 166          //  * @retval 无
 167          //  */
 168          //void I2C_Stop(void)
 169          //{
 170          //  I2C_SDA=0;  //先把SDA拉低
 171          //  I2C_SCL=1;  //再把SCL拉高
 172          //  I2C_SDA=1;  //当SCL为高电平时，SDA由低变为高
 173          //}
 174          
 175          ///**
 176          //  * @brief  I2C发送一个字节
 177          //  * @param  Byte 要发送的字节
C51 COMPILER V9.60.7.0   IIC                                                               11/11/2023 13:00:54 PAGE 4   

 178          //  * @retval 无
 179          //  */
 180          //void I2C_SendByte(u8 Byte)
 181          //{
 182          //  u8 i;
 183          //  for(i=0;i<8;i++)
 184          //  {                         //先传高位再传低位
 185          //    I2C_SDA=Byte&(0x80>>i); //取出最高位把值赋给SDA，接着再右移一位再取出来赋给SDA，以此类推循环八次
 186          //    I2C_SCL=1;  //为1数据稳定等待下一次传输
 187          //    I2C_SCL=0;  //数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输
 188          //  }
 189          //}
 190          
 191          ///**
 192          //  * @brief  I2C接收一个字节
 193          //  * @param  无
 194          //  * @retval 接收到的一个字节数据
 195          //  */
 196          //u8 I2C_ReceiveByte(void)
 197          //{
 198          //  u8 i,Byte=0x00;
 199          //  I2C_SDA=1;
 200          //  for(i=0;i<8;i++)
 201          //  {
 202          //    I2C_SCL=1;    //SCL为1时数据稳定，可以传输数据
 203          //    if(I2C_SDA)   //如果SDA为1
 204          //    {
 205          //      Byte|=(0x80>>i); //进入该循环表示Byte接收到1，如果SDA等于0，则默认Byte接收到0，不进入循环
 206          //    }
 207          //    I2C_SCL=0;    //数据传输完毕，让SCL为0，使下一次数据可以改变并进行传输
 208          //  }
 209          //  return Byte;
 210          //}
 211          
 212          ///**
 213          //  * @brief  I2C发送应答
 214          //  * @param  AckBit 应答位，0为应答，1为非应答
 215          //  * @retval 无
 216          //  */
 217          //void I2C_SendAck(u8 AckBit)
 218          //{
 219          //  I2C_SDA=AckBit; //应答位赋给SDA
 220          //  I2C_SCL=1;      //把SCL拉高
 221          //  I2C_SCL=0;      //再把SCL拉低
 222          //}
 223          
 224          ///**
 225          //  * @brief  I2C接收应答位
 226          //  * @param  无
 227          //  * @retval 接收到的应答位，0为应答，1为非应答
 228          //  */
 229          //u8 I2C_ReceiveAck(void)
 230          //{
 231          //  u8 AckBit;
 232          //  I2C_SDA=1;
 233          //  I2C_SCL=1;
 234          //  AckBit=I2C_SDA; //SDA为0接收应答，为0为非应答
 235          //  I2C_SCL=0;
 236          //  return AckBit;
 237          //}


C51 COMPILER V9.60.7.0   IIC                                                               11/11/2023 13:00:54 PAGE 5   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
